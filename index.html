<html>

<head>
  <!-- https://github.com/flowyapps/honey-require The 'honey-require' library loads modules like node's require module does
    and since antlr4 generated code is targeted for the node environment you need this kind of 'require' library to use it in
    the browser. The widely used 'require' library on the browser requires a very different structure for modules and is not
    employed here. -->
  <script src='js/honey-require.js'></script>
  <script src="js/jquery.min.js"></script>
</head>
<style>
  #inputBox {
    padding: 2px;
    height: 30px;
    position: relative;
    left: 2px;
    outline: 1px;
    font-size: 16px;    
  }
  .valid {
    border: 1px solid #224400;
    border-color: rgba(0, 0, 0, .15);
    background-color: #CCFF99;
  }
  .invalid {
    border: 1px solid #7A0000;
    border-color: rgba(0, 0, 0, .15);
    background-color: #FFCCCC;    
  }
</style>

<body style="font-family: sans-serif;">
  <input id='inputBox'></input>   Try: (1+2+3)*4
  <br/><br/>
  <div id="resultDiv"></div>
  
  <script>
    //antlr4 runtime library
    var antlr4 = require('antlr4/index');     
    //Generated lexer, parser, and listener libraries, specific to our grammar
    var CalculatorLexer = require('js/CalculatorLexer.js');
    var CalculatorParser = require('js/CalculatorParser.js');
    var CalculatorListener = require('js/CalculatorListener.js').CalculatorListener;

    var myInput = document.getElementById("inputBox");

    var stack = new Array();
  
    //myCalculatorListener
    //Class for catching parser token events, like enterNumber, exitAddSubtract (which are generated by antlr4 based on grammar # comments)
    var myCalculatorListener = function () {
      CalculatorListener.call(this); // inherit default listener
    };
    
    myCalculatorListener.prototype = Object.create(CalculatorListener.prototype);
    myCalculatorListener.prototype.constructor = myCalculatorListener;
    
    //Override the default generated exitMultiplyDivide event (from CalculatorListener.js)
    myCalculatorListener.prototype.exitMultiplyDivide = function(ctx) {
      var number1 = stack.pop();
      var number2 = stack.pop();
      var result;
      
      if (ctx.parser.symbolicNames[ctx.operator.type] === "MULTIPLY") {
        result = number2 * number1;
      } 
      else if (ctx.parser.symbolicNames[ctx.operator.type] === "DIVIDE") {
        result = number2 / number1;
      } 
      else {
        throw new AssertionError("Unhandled Token " + ctx.operator);
      }
      
      stack.push(result);
    }; 
    
    //Override the default
    myCalculatorListener.prototype.enterNumber = function(ctx) {
      stack.push(Number(ctx.getText()));
    }; 
      
    //Override the default
    myCalculatorListener.prototype.exitAddSubtract = function(ctx) {
        var number1 = stack.pop();
        var number2 = stack.pop();
        var result;
    
        if (ctx.parser.symbolicNames[ctx.operator.type] === "ADD") {
          result = number2 + number1;
        } else if (ctx.parser.symbolicNames[ctx.operator.type] === "SUBTRACT") {
          result = number2 - number1;
        } else {
          throw new AssertionError("Unhandled Token " + ctx.operator);
        }
        stack.push(result);
    };
    
    //Override the default
    myCalculatorListener.prototype.exitNegate = function(ctx) {
      var number1 = stack.pop();
      number1 = -number1;
      stack.push(number1);
    };
  
    //myErrorListener
    //Class for gathering errors and displaying them
    var myErrorListener = function(parseErrors) {
      antlr4.error.ErrorListener.call(this);
      this.parseErrors = parseErrors;
      return this;
    };
    
    myErrorListener.prototype = Object.create(antlr4.error.ErrorListener.prototype);
    myErrorListener.prototype.constructor = myErrorListener;
    myErrorListener.prototype.syntaxError = function(recognizer, offendingSymbol, line, column, msg, e) {    
      this.parseErrors.push({
        character: column,
        msg: msg
      });
    };

    
    //Reparse the text for every key typed in the textbox
    $( "#inputBox" ).keyup(function(e) {
      var input,
          chars,
          lexer,
          tokens,
          parser,
          tree,
          parseErrors,
          listener;  
      $('#resultDiv').text('working...');
          
      input = $('#inputBox').val(),
      chars = new antlr4.InputStream(input),
      lexer = new CalculatorLexer.CalculatorLexer(chars),
      tokens = new antlr4.CommonTokenStream(lexer),
      parser = new CalculatorParser.CalculatorParser(tokens);

      //Used for pushing and popping tokens found by parser to do math calculations.  Clear the stack before parsing.
      stack = [];
      
      // set up to listen to parser complain about errors it finds
      parseErrors = [];
      listener = new myErrorListener(parseErrors)
      parser.removeErrorListeners();    //Remove default ErrorListener, and replace it with ours.
      parser.addErrorListener(listener);
    
        
      try {
        tree = parser.expression();	// "expression" is the name of the first rule in the grammar.  Could have been "foo" or anything else.
        //The ParseTreeWalker is what traverses the tree and calls the events
        antlr4.tree.ParseTreeWalker.DEFAULT.walk(new myCalculatorListener(), tree);      
      }
      //antlr4 throws many different kinds of errors.  Our myErrorListener catches parser errors (and lexer errors passed on to parser) but not other types, such as RecognitionException.  
      //So this is a catch all to just output any uncaught errors to console.
      catch(err) {
        console.log(err); 
      }      
            
      if (parseErrors.length) {
        $(this).removeClass('valid').addClass('invalid');   //make inputBox red
        
        //Get html to display all errors
        var message = "";        
        parseErrors.forEach(function(parseError) {
          message += parseError.msg + ' (character ' + parseError.character + ')<br/>';
        });
        $('#resultDiv').html(message);
      } 
      else {
        $(this).removeClass('invalid').addClass('valid');      //make inputBox green
        $('#resultDiv').text("Result: " + stack[stack.length-1]);
      }
    
    });
  </script>
</body>

</html>
